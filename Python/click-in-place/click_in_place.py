#!/usr/bin/env python3
"""
Click-in-Place: A program that detects mouse click positions and automatically
repeats clicks at the same position with a configurable interval.
"""

import time
import logging
import argparse
import threading
import os
from datetime import datetime
from typing import Optional, Tuple
from pynput import mouse, keyboard


class ClickInPlace:
    """Main class for detecting and repeating mouse clicks."""
    
    def __init__(self, interval: float = 60.0, repeat_count: int = 10, timeout: float = 60.0, 
                 click_x: Optional[int] = None, click_y: Optional[int] = None, log_level: str = "INFO"):
        """
        Initialize the Click-in-Place application.
        
        Args:
            interval: Time in seconds between repeated clicks (default: 60.0)
            repeat_count: Number of times to repeat the click (default: 10)
            timeout: Maximum runtime in seconds before program exits (default: 60.0)
            click_x: X coordinate for clicking position (optional, if provided with click_y, starts clicking automatically)
            click_y: Y coordinate for clicking position (optional, if provided with click_x, starts clicking automatically)
            log_level: Logging level (DEBUG, INFO, WARNING, ERROR)
        """
        self.interval = interval
        self.repeat_count = repeat_count
        self.timeout = timeout
        self.start_time = time.time()
        self.click_position: Optional[Tuple[int, int]] = None
        # Track if coordinates were provided via command line
        self.coordinates_provided = False
        # Set initial position if provided via command line
        if click_x is not None and click_y is not None:
            self.click_position = (click_x, click_y)
            self.coordinates_provided = True
        self.is_clicking = False
        self.click_thread: Optional[threading.Thread] = None
        self.mouse_listener: Optional[mouse.Listener] = None
        self.keyboard_listener: Optional[keyboard.Listener] = None
        self.should_exit = False
        self.click_lock = threading.Lock()  # Lock for thread synchronization
        self.is_program_clicking = False  # Flag to ignore program-generated clicks
        
        # Setup logging with file handler
        log_format = '%(asctime)s - %(levelname)s - %(message)s'
        date_format = '%Y-%m-%d %H:%M:%S'
        log_level_attr = getattr(logging, log_level.upper())
        
        # Create log filename with timestamp
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        log_filename = f'click_in_place_{timestamp}.log'
        
        # Configure root logger
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(log_level_attr)
        
        # Remove existing handlers to avoid duplicates
        self.logger.handlers = []
        
        # Console handler
        console_handler = logging.StreamHandler()
        console_handler.setLevel(log_level_attr)
        console_formatter = logging.Formatter(log_format, date_format)
        console_handler.setFormatter(console_formatter)
        self.logger.addHandler(console_handler)
        
        # File handler
        file_handler = logging.FileHandler(log_filename, encoding='utf-8')
        file_handler.setLevel(log_level_attr)
        file_formatter = logging.Formatter(log_format, date_format)
        file_handler.setFormatter(file_formatter)
        self.logger.addHandler(file_handler)
        
        self.log_file = log_filename
        
        # Create mouse controller for simulating clicks
        self.mouse_controller = mouse.Controller()
        
        self.logger.info("Click-in-Place initialized")
        self.logger.info(f"Log file: {self.log_file}")
        self.logger.info(f"Repeat interval: {self.interval} seconds")
        self.logger.info(f"Repeat count: {self.repeat_count} clicks")
        self.logger.info(f"Program timeout: {self.timeout} seconds")
    
    def on_click(self, x: int, y: int, button: mouse.Button, pressed: bool):
        """
        Callback function for mouse click events.
        
        Args:
            x: X coordinate of the click
            y: Y coordinate of the click
            button: Mouse button that was clicked
            pressed: True if button was pressed, False if released
        """
        # Ignore clicks generated by the program itself
        if self.is_program_clicking:
            return
        
        if pressed and button == mouse.Button.left:
            # Capture the actual mouse position immediately when click is detected
            # This is more accurate than relying on listener coordinates which may have DPI scaling issues
            actual_position = self.mouse_controller.position
            actual_x, actual_y = int(round(actual_position[0])), int(round(actual_position[1]))
            
            # Log click detection with coordinates (always logged to file)
            self.logger.info(f"CLICK DETECTED - Coordinates: ({actual_x}, {actual_y}) | Listener reported: ({x}, {y})")
            
            # Log coordinate mismatch if significant
            if abs(x - actual_x) > 2 or abs(y - actual_y) > 2:
                self.logger.warning(f"Coordinate mismatch detected - Listener: ({x}, {y}), Actual mouse: ({actual_x}, {actual_y})")
                self.logger.info(f"Using actual mouse position for accuracy: ({actual_x}, {actual_y})")
            else:
                self.logger.debug(f"Coordinates match - Listener: ({x}, {y}), Actual: ({actual_x}, {actual_y})")
            
            # If clicking is already in progress, stop it first
            if self.is_clicking:
                self.logger.info(f"New click position detected. Stopping current clicking and switching to new position.")
                self.stop_clicking()
                # Wait a moment for the thread to stop completely
                time.sleep(0.3)
            
            # Use the actual mouse position for maximum accuracy
            self.click_position = (actual_x, actual_y)
            self.logger.info(f"User click captured at position: ({actual_x}, {actual_y})")
            self.logger.info("Waiting 5 seconds before starting clicks...")
            
            # Wait 5 seconds before starting the clicking sequence
            time.sleep(5.0)
            
            # Start clicking at the new position
            self.start_clicking()
    
    def start_clicking(self):
        """Start the automatic clicking thread."""
        if self.click_position is None:
            self.logger.error("No click position recorded. Please click somewhere first.")
            return
        
        # If already clicking, wait for it to stop (shouldn't happen due to on_click logic, but safety check)
        if self.is_clicking:
            self.logger.warning("Clicking is already active. Waiting for it to stop...")
            self.stop_clicking()
            time.sleep(0.2)
        
        with self.click_lock:
            self.is_clicking = True
            self.should_exit = False  # Reset exit flag when starting new clicking sequence
        
        self.click_thread = threading.Thread(target=self._click_loop, daemon=True)
        self.click_thread.start()
        self.logger.info(f"Started automatic clicking at position {self.click_position}")
        self.logger.info(f"Click interval: {self.interval} seconds")
        if self.repeat_count == 0:
            self.logger.info("Will perform clicks indefinitely (repeat-count is 0)")
        else:
            self.logger.info(f"Will perform {self.repeat_count} clicks total")
    
    def stop_clicking(self):
        """Stop the automatic clicking."""
        with self.click_lock:
            if not self.is_clicking:
                self.logger.warning("Clicking is not active.")
                return
            
            self.is_clicking = False
        
        if self.click_thread:
            self.click_thread.join(timeout=2.0)
        self.logger.info("Stopped automatic clicking")
    
    def _click_loop(self):
        """Internal method that performs the repeated clicking."""
        click_count = 0
        # Store the position at the start of the loop to avoid it changing mid-loop
        target_position = self.click_position
        
        if target_position is None:
            self.logger.error("Click position is None. Stopping click loop.")
            return
        
        x, y = target_position
        self.logger.info(f"Starting click loop at position ({x}, {y})")
        
        # Save original mouse position to restore later
        original_position = self.mouse_controller.position
        
        try:
            # Move mouse to target position once at the start
            self.mouse_controller.position = (x, y)
            # Wait longer to ensure mouse has fully moved to position
            time.sleep(0.1)
            
            # Verify position (with small tolerance for DPI scaling)
            current_pos = self.mouse_controller.position
            if abs(current_pos[0] - x) > 1 or abs(current_pos[1] - y) > 1:
                self.logger.warning(f"Mouse position mismatch. Expected ({x}, {y}), got {current_pos}. Correcting...")
                # Try to correct it multiple times if needed
                for attempt in range(3):
                    self.mouse_controller.position = (x, y)
                    time.sleep(0.1)
                    current_pos = self.mouse_controller.position
                    if abs(current_pos[0] - x) <= 1 and abs(current_pos[1] - y) <= 1:
                        break
                    self.logger.debug(f"Position correction attempt {attempt + 1}: {current_pos}")
            
            while True:
                # Check if we should continue (with lock protection)
                # If repeat_count is 0, continue indefinitely
                with self.click_lock:
                    if self.repeat_count == 0:
                        should_continue = self.is_clicking
                    else:
                        should_continue = self.is_clicking and click_count < self.repeat_count
                
                if not should_continue:
                    break
                
                try:
                    # Ensure we're still at the correct position before each click
                    current_pos = self.mouse_controller.position
                    if abs(current_pos[0] - x) > 1 or abs(current_pos[1] - y) > 1:
                        self.mouse_controller.position = (x, y)
                        time.sleep(0.05)  # Small delay for position correction
                    
                    # Set flag to ignore this click in the listener
                    self.is_program_clicking = True
                    
                    # Perform click at the exact position
                    self.mouse_controller.click(mouse.Button.left, 1)
                    
                    # Small delay to ensure click is registered before clearing flag
                    time.sleep(0.05)
                    self.is_program_clicking = False
                    
                    click_count += 1
                    
                    # Log click information (always logged to file)
                    if self.repeat_count == 0:
                        self.logger.info(f"CLICK PERFORMED #{click_count} - Coordinates: ({x}, {y}) - continuing indefinitely")
                    else:
                        remaining = self.repeat_count - click_count
                        self.logger.info(f"CLICK PERFORMED {click_count}/{self.repeat_count} - Coordinates: ({x}, {y}) - {remaining} remaining")
                    
                    # Check if we've reached the repeat count (only if repeat_count > 0)
                    if self.repeat_count > 0 and click_count >= self.repeat_count:
                        self.logger.info(f"Completed all {self.repeat_count} clicks. Program will exit.")
                        with self.click_lock:
                            self.is_clicking = False
                            self.should_exit = True
                        break
                    
                    # Wait for the specified interval (always wait if repeat_count is 0, or if not the last click)
                    if self.repeat_count == 0 or click_count < self.repeat_count:
                        # Sleep for the full interval, checking periodically if we should stop
                        sleep_interval = min(0.5, self.interval / 10)  # Check every 0.5s or 10% of interval, whichever is smaller
                        total_slept = 0.0
                        while total_slept < self.interval:
                            with self.click_lock:
                                if not self.is_clicking:
                                    break
                            time.sleep(sleep_interval)
                            total_slept += sleep_interval
                            
                except Exception as e:
                    self.logger.error(f"Error during click loop iteration: {e}", exc_info=True)
                    self.is_program_clicking = False
                    break
        except Exception as e:
            self.logger.error(f"Error during click loop setup: {e}", exc_info=True)
            self.is_program_clicking = False
        finally:
            # Restore original mouse position
            try:
                self.mouse_controller.position = original_position
            except:
                pass
            self.is_program_clicking = False
            if self.repeat_count == 0:
                self.logger.info(f"Click loop ended. Total clicks performed: {click_count} (infinite mode)")
            else:
                self.logger.info(f"Click loop ended. Total clicks performed: {click_count}/{self.repeat_count}")
    
    def on_key_press(self, key):
        """
        Callback function for keyboard events.
        
        Args:
            key: The key that was pressed
        """
        try:
            # Exit program on ESC key
            if key == keyboard.Key.esc:
                self.logger.info("ESC key pressed. Exiting program...")
                self.stop_clicking()
                with self.click_lock:
                    self.should_exit = True
                return False  # Stop listener
        except AttributeError:
            # Handle special keys
            pass
    
    def _timeout_thread(self):
        """Thread that exits the program after the timeout period."""
        time.sleep(self.timeout)
        elapsed = time.time() - self.start_time
        self.logger.info(f"Timeout reached ({self.timeout} seconds). Program will exit.")
        with self.click_lock:
            self.is_clicking = False
            self.should_exit = True
    
    def run(self):
        """Start the application and listen for mouse clicks."""
        self.logger.info("=" * 60)
        self.logger.info("Click-in-Place is now active")
        self.logger.info("Instructions:")
        if self.coordinates_provided:
            self.logger.info(f"  - Pre-configured click position: {self.click_position}")
            self.logger.info("  - Program will start clicking at this position after 5 seconds")
            self.logger.info("  - Mouse click detection is DISABLED (using provided coordinates)")
        else:
            self.logger.info("  - Left-click anywhere to start auto-clicking at that position")
            self.logger.info("  - Left-click at a new position to switch to that position immediately")
        if self.repeat_count == 0:
            self.logger.info("  - Program will click indefinitely (repeat-count is 0)")
        else:
            self.logger.info(f"  - Program will automatically perform {self.repeat_count} clicks")
        self.logger.info(f"  - Interval between clicks: {self.interval} seconds")
        if self.timeout == 0:
            self.logger.info("  - Program will run indefinitely (timeout is 0)")
        else:
            self.logger.info(f"  - Program will exit after {self.timeout} seconds (timeout)")
        self.logger.info("  - Press ESC to exit the program")
        if self.repeat_count == 0 and self.timeout == 0:
            self.logger.info("  - Program will run indefinitely until ESC is pressed")
        elif self.repeat_count == 0:
            self.logger.info("  - Program will exit after timeout or ESC key")
        elif self.timeout == 0:
            self.logger.info("  - Program will exit after all clicks are completed or ESC key")
        else:
            self.logger.info("  - Program will exit after all clicks are completed, timeout, or ESC key")
        self.logger.info("=" * 60)
        
        # Start timeout thread if timeout is set
        timeout_thread = None
        if self.timeout > 0:
            timeout_thread = threading.Thread(target=self._timeout_thread, daemon=True)
            timeout_thread.start()
            self.logger.info(f"Timeout thread started. Program will exit in {self.timeout} seconds.")
        
        # Only start mouse listener if coordinates were NOT provided via command line
        if not self.coordinates_provided:
            # Start mouse listener
            self.mouse_listener = mouse.Listener(on_click=self.on_click)
            self.mouse_listener.start()
            self.logger.info("Mouse listener started")
        else:
            self.logger.info("Mouse listener NOT started (coordinates provided via command line)")
        
        # Start keyboard listener
        self.keyboard_listener = keyboard.Listener(on_press=self.on_key_press)
        self.keyboard_listener.start()
        self.logger.info("Keyboard listener started")
        
        # If position was provided via command line, start clicking after 5 seconds
        if self.coordinates_provided:
            x, y = self.click_position
            self.logger.info(f"Pre-configured position detected: ({x}, {y})")
            self.logger.info("Waiting 5 seconds before starting clicks...")
            time.sleep(5.0)
            self.start_clicking()
        
        try:
            # Keep the main thread alive until clicking is done or interrupted
            while not self.should_exit:
                time.sleep(0.1)
                if self.is_clicking and self.click_thread and not self.click_thread.is_alive():
                    # Click thread finished, check if we should exit
                    if self.should_exit:
                        break
        except KeyboardInterrupt:
            self.logger.info("Keyboard interrupt received. Shutting down...")
        finally:
            self.cleanup()
    
    def cleanup(self):
        """Clean up resources and stop all listeners."""
        self.logger.info("Cleaning up resources...")
        self.stop_clicking()
        
        if self.mouse_listener:
            self.mouse_listener.stop()
            self.logger.info("Mouse listener stopped")
        
        if self.keyboard_listener:
            self.keyboard_listener.stop()
            self.logger.info("Keyboard listener stopped")
        
        self.logger.info("Application terminated")
        self.logger.info(f"Log file saved: {self.log_file}")


def main():
    """Main entry point for the application."""
    parser = argparse.ArgumentParser(
        description="Detect mouse click positions and automatically repeat clicks",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Start with default settings (60 second interval, 10 repeats, 60 second timeout)
  python click_in_place.py
  
  # Start with 30 second interval, 5 repeats, and 120 second timeout
  python click_in_place.py --interval 30.0 --repeat-count 5 --timeout 120.0
  
  # Start with 2 second interval, 20 repeats, debug logging, and no timeout
  python click_in_place.py --interval 2.0 --repeat-count 20 --log-level DEBUG --timeout 0
  
  # Start clicking at position (500, 300) automatically after 5 seconds
  python click_in_place.py --click-x 500 --click-y 300
  
  # Start clicking at position with custom interval and repeat count
  python click_in_place.py --click-x 500 --click-y 300 --interval 2.0 --repeat-count 5
        """
    )
    
    parser.add_argument(
        '--interval',
        type=float,
        default=60.0,
        help='Time interval in seconds between repeated clicks (default: 60.0)'
    )
    
    parser.add_argument(
        '--repeat-count',
        type=int,
        default=10,
        help='Number of times to repeat the click (default: 10). Set to 0 for infinite repeats.'
    )
    
    parser.add_argument(
        '--log-level',
        type=str,
        default='INFO',
        choices=['DEBUG', 'INFO', 'WARNING', 'ERROR'],
        help='Logging level (default: INFO)'
    )
    
    parser.add_argument(
        '--timeout',
        type=float,
        default=60.0,
        help='Maximum runtime in seconds before program exits (default: 60.0). Set to 0 to disable timeout.'
    )
    
    parser.add_argument(
        '--click-x',
        type=int,
        default=None,
        help='X coordinate for clicking position (must be used with --click-y). If provided, starts clicking automatically after 5 seconds.'
    )
    
    parser.add_argument(
        '--click-y',
        type=int,
        default=None,
        help='Y coordinate for clicking position (must be used with --click-x). If provided, starts clicking automatically after 5 seconds.'
    )
    
    args = parser.parse_args()
    
    # Validate interval
    if args.interval <= 0:
        print("Error: Interval must be greater than 0")
        return 1
    
    # Validate repeat count (0 means infinite)
    if args.repeat_count < 0:
        print("Error: Repeat count must be 0 or greater (0 means infinite)")
        return 1
    
    # Validate timeout
    if args.timeout < 0:
        print("Error: Timeout must be 0 or greater (0 disables timeout)")
        return 1
    
    # Validate click position arguments
    if (args.click_x is not None and args.click_y is None) or (args.click_x is None and args.click_y is not None):
        print("Error: Both --click-x and --click-y must be provided together")
        return 1
    
    # Create and run the application
    app = ClickInPlace(
        interval=args.interval, 
        repeat_count=args.repeat_count, 
        timeout=args.timeout,
        click_x=args.click_x,
        click_y=args.click_y,
        log_level=args.log_level
    )
    app.run()
    
    return 0


if __name__ == "__main__":
    exit(main())

